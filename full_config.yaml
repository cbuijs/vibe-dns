# =============================================================================
# VIBE-DNS FULL CONFIGURATION
# Version: 5.0.0 (Recursive Resolution & DNSSEC Support)
# =============================================================================
# This file documents ALL configuration options with explanations and examples.
# Copy and modify sections as needed for your deployment.
# =============================================================================

# =============================================================================
# 1. LOGGING
# found in: utils.py, defaults.py
# =============================================================================
logging:
  # Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
  level: "INFO"
  
  # Print logs to stdout (terminal)
  enable_console: true
  
  # Include timestamp in console logs (set false if using systemd/docker)
  console_timestamp: true
  
  # Write logs to a file
  enable_file: false
  file_path: "./dns_server.log"
  
  # Send logs to local Syslog or remote Syslog server
  enable_syslog: false
  # Can be a file path (e.g., /dev/log) or "host:port" (e.g., 192.168.1.50:514)
  syslog_address: "/dev/log"
  # Protocol if sending over network: UDP or TCP
  syslog_protocol: "UDP"

# =============================================================================
# 2. SERVER NETWORKING
# found in: server.py, resolver.py
# =============================================================================
server:
  # List of IPs to listen on.
  # Use "0.0.0.0" for all IPv4, "::" for all IPv6.
  bind_ip: 
    - "0.0.0.0"
    - "::"
  
  # OPTIONAL: Bind by interface name (requires 'netifaces' module or 'ip' command). 
  # These are resolved to IPs at startup and added to bind_ip.
  # bind_interfaces: 
  #   - "eth0"
  #   - "wg0"
  
  # Ports to listen on (List of integers). Standard is 53.
  port_udp: [53, 5353, 53053]
  port_tcp: [53, 5353, 53053]

  # Max concurrent UDP requests to process simultaneously.
  # Packets exceeding this limit are dropped to prevent resource exhaustion.
  udp_concurrency: 1000

  tls:
    enabled: false  # Set to true to enable DoH/DoT
    enable_dot: true
    enable_doh: true

    # Ports to listen on
    port_dot: [853, 8853]
    port_doh: [443, 8443]
    
    # Certificate paths (required when enabled)
    cert_file: "/path/to/cert.pem"
    key_file: "/path/to/key.pem"
    # ca_file: "/path/to/ca.pem"  # Optional: for client cert verification
    
    # DoH specific settings
    doh_paths: ["/", "/dns-query"]  # RFC 8484 standard path
    doh_strict_paths: false
  
  # --- EDNS Client Subnet (ECS) Handling ---
  # Enable parsing of ECS data from incoming clients
  use_ecs: true
  
  # How to handle ECS when forwarding to upstream:
  # - none:     Strip ECS data (Default/Privacy)
  # - preserve: Forward client's provided ECS data if present
  # - add:      Inject the client's actual IP as ECS data
  # - privacy:  Truncate client IP to mask (defined below) before forwarding
  # - override: Force a specific IP (defined below) to be sent as ECS
  forward_ecs_mode: "none"

  # ECS Masks for 'privacy' mode (Subnet bits to keep)
  ecs_ipv4_mask: 24
  ecs_ipv6_mask: 56

  # ECS Overrides for 'override' mode (Simulate request from this IP)
  # ecs_override_ipv4: "1.2.3.4"
  # ecs_override_ipv6: "2001:db8::1"

  # --- MAC Address Handling ---
  # Enable parsing of custom EDNS MAC option (Code 65001)
  use_edns_mac: true
  
  # How to handle MAC forwarding to upstream:
  # - none:     Do not send MAC to upstream
  # - preserve: Forward existing MAC option if present
  # - add:      Resolve client MAC from ARP table and inject it via EDNS
  forward_mac_mode: "none"

# =============================================================================
# 3. GEOIP CONFIGURATION
# found in: geoip.py, cctld.py
# =============================================================================
geoip:
  # Master switch for GeoIP functionality
  enabled: true
  
  # Path to the binary database compiled via geoip_compiler.py
  unified_database: "./geoip.vibe"
  
  # Logic for mapping Domain TLDs (e.g., .cn) vs IP Locations
  # - geoip_only:  Ignore TLDs. Only use IP-based lookup of the answer.
  # - cctld_first: If domain TLD matches a blocked location, block query immediately.
  # - cctld_geoip: Use TLD as a hint to disambiguate IP location.
  cctld_mode: "geoip_only"

# =============================================================================
# 4. UPSTREAM RESOLUTION
# found in: upstream_manager.py, recursive_resolver.py
# =============================================================================
upstream:
  # Check if upstreams are reachable before starting the server
  startup_check_enabled: true
  
  # If all configured servers fail, use bootstrap servers as last resort
  fallback_enabled: false
  
  # Allow non-RFC compliant underscores in domain names (e.g., _service.example.com)
  allow_underscores: false
  
  # Load Balancing Strategy (for forwarding mode):
  # - fastest:     Use server with lowest latency (pings periodically)
  # - loadbalance: Distribute based on average response time
  # - distributed: Weighted distribution based on latency and staleness
  # - failover:    Use first server; only switch if it fails
  # - random:      Pick random server per request
  # - roundrobin:  Rotate through servers sequentially
  # - sticky:      Client IP is pinned to specific upstream server
  # - none:        Use first available (dumb forwarder)
  mode: "fastest"
  
  # Seconds between latency probes
  monitor_interval: 60
  
  # Trigger background latency check immediately if a user queries a domain
  monitor_on_query: true
  
  # Domain used for latency probing
  test_domain: "www.google.com"
  
  # Max concurrent connections per HTTP/2 client (for DoH upstreams)
  connection_limit: 20
  
  # --- Circuit Breaker ---
  # Temporarily stops sending queries to a dead upstream
  circuit_breaker_enabled: true
  circuit_failure_threshold: 3   # Number of failures before opening circuit
  circuit_recovery_timeout: 30   # Seconds to wait before retrying a dead server

  # Bootstrap DNS servers 
  # Used to resolve hostnames of DoH/DoT upstreams (e.g. resolving dns.google)
  bootstrap:
    - "8.8.8.8"
    - "1.1.1.1"

  # Control which IP version is resolved for upstream hosts via bootstrap servers.
  # - ipv4: Only request A records (IPv4).
  # - ipv6: Only request AAAA records (IPv6).
  # - both: Request both A and AAAA records (Default).
  # - auto: Detect based on configured bootstrap IPs.
  bootstrap_resolution_mode: "auto"

  # Upstream Server Definitions (for forwarding mode)
  # Syntax: protocol://host:port/path#forced_ip
  # Protocols: udp, tcp, tls (DoT), https (DoH)
  groups:
    Default:
      servers:
        - url: "udp://8.8.8.8:53"
          priority: 10
        - url: "udp://1.1.1.1:53"
          priority: 20
    
    Secure:
      servers:
        # DoT Example (Forced IP prevents bootstrap lookup)
        - url: "tls://1.1.1.1:853#1.1.1.1"
        # DoH Example
        - url: "https://dns.google:443/dns-query#8.8.4.4"

    LocalUpstream:
      servers:
        - "udp://192.168.1.1:53"  # Local router/DNS

  # =========================================================================
  # RECURSIVE RESOLUTION (NEW in v5.0)
  # =========================================================================
  # When enabled, the server can resolve queries iteratively from root servers
  # instead of forwarding to upstream resolvers. This gives you full control
  # over DNS resolution and enables DNSSEC validation.
  # =========================================================================
  recursive:
    # Master switch for recursive resolution
    # When false (default), the server forwards queries to upstream servers.
    # When true, the server walks the DNS tree from root servers.
    enabled: false

    # RFC 9156: QNAME Minimization support
    # When enabled, the resolver hides the full query name from authoritative servers
    # by only querying for the labels necessary to find the next delegation point.
    # - strict: Only use minimized qnames, could break resolution.
    # - relaxed: Use minimizations but fallback to full qnames when ecnountering issues.
    # - off - No qname minimizations.
    qname_minimization: "relaxed"
    
    # Prefer IPv6 when querying authoritative nameservers
    prefer_ipv6: false
    
    # Query timeout in seconds for each nameserver query
    query_timeout: 5
    
    # NS cache size (caches discovered nameservers during resolution)
    ns_cache_size: 10000
    ns_cache_ttl: 86400
    
    # -------------------------------------------------------------------------
    # Root Hints Configuration
    # -------------------------------------------------------------------------
    # Root hints tell the resolver where to find the DNS root servers.
    # These are the starting point for all recursive resolution.
    # -------------------------------------------------------------------------
    root_hints:
      # Source for root hints:
      # - builtin: Use built-in root server list (recommended, updated periodically)
      # - url:     Fetch from InterNIC (https://www.internic.net/domain/named.root)
      # - file:    Load from local file in named.root format
      source: "builtin"
      
      # URL to fetch named.root (when source=url)
      url: "https://www.internic.net/domain/named.root"
      
      # File path to named.root (when source=file)
      # file: "./named.root"
      
      # Refresh interval in seconds (for url/file sources)
      # Root hints rarely change, daily refresh is sufficient
      refresh_interval: 86400
    
    # -------------------------------------------------------------------------
    # Trust Anchors Configuration (for DNSSEC)
    # -------------------------------------------------------------------------
    # Trust anchors are the root of trust for DNSSEC validation.
    # They contain the root zone's public key (or its hash).
    # -------------------------------------------------------------------------
    trust_anchors:
      # Source for trust anchors:
      # - builtin: Use built-in root KSK (key tag 20326, current as of 2024)
      # - url:     Fetch from IANA (https://data.iana.org/root-anchors/root-anchors.xml)
      # - file:    Load from local file in root-anchors.xml format
      source: "builtin"
      
      # URL to fetch root-anchors.xml (when source=url)
      url: "https://data.iana.org/root-anchors/root-anchors.xml"
      
      # File path to root-anchors.xml (when source=file)
      # file: "./root-anchors.xml"
      
      # Refresh interval in seconds (for url/file sources)
      refresh_interval: 86400
    
    # -------------------------------------------------------------------------
    # DNSSEC Validation Configuration
    # -------------------------------------------------------------------------
    # DNSSEC (DNS Security Extensions) provides authentication and integrity
    # for DNS responses. When enabled, the resolver validates signatures
    # on DNS records back to the root trust anchor.
    # -------------------------------------------------------------------------
    dnssec:
      # Validation mode - controls how DNSSEC validation affects responses:
      #
      # - none:     No validation performed (fastest, no security)
      #             All responses are passed through unchanged.
      #
      # - log:      Validate and LOG results, but never block
      #             Useful for testing/monitoring before enforcing.
      #             Logs show: ✓ SECURE, ○ INSECURE, ✗ BOGUS, ? INDETERMINATE
      #
      # - standard: Block BOGUS/INDETERMINATE, allow SECURE/INSECURE (recommended)
      #             - SECURE:        Validated successfully, AD flag set
      #             - INSECURE:      Zone is unsigned (no DNSSEC), passed through
      #             - BOGUS:         Validation FAILED -> returns SERVFAIL
      #             - INDETERMINATE: Cannot determine -> returns SERVFAIL
      #
      # - strict:   Only SECURE responses pass (high security, may break sites)
      #             - SECURE:        Validated successfully, passed through
      #             - INSECURE:      Zone is unsigned -> returns SERVFAIL
      #             - BOGUS:         Validation failed -> returns SERVFAIL
      #             - INDETERMINATE: Cannot determine -> returns SERVFAIL
      #
      # Recommendation: Start with "log" to assess impact, then move to "standard"
      mode: "none"
      
      # Response code for failed DNSSEC validation (BOGUS/INDETERMINATE)
      # Applies to 'standard' and 'strict' modes
      # Options: SERVFAIL (recommended), REFUSED, NXDOMAIN
      validation_failure_rcode: "SERVFAIL"
      
      # Response code for unsigned zones (strict mode only)
      # When mode=strict, unsigned zones are considered invalid
      unsigned_zone_rcode: "SERVFAIL"
      
      # Cache validation results to improve performance
      cache_validated: true
      
      # TTL for cached BOGUS results (negative cache)
      # Prevents repeated validation attempts for known-bad zones
      cache_ttl: 300
      
      # Disable specific DNSSEC algorithms (by number)
      # Useful for blocking weak/deprecated algorithms
      # Common algorithms:
      #   5  = RSASHA1 (deprecated, potentially vulnerable)
      #   7  = RSASHA1-NSEC3-SHA1 (deprecated)
      #   8  = RSASHA256 (recommended)
      #   13 = ECDSAP256SHA256 (recommended)
      #   14 = ECDSAP384SHA384
      #   15 = ED25519 (recommended)
      #   16 = ED448
      # Example: [5, 7] disables RSASHA1 variants
      disabled_algorithms: []

# =============================================================================
# 5. CACHING
# found in: cache_stats.py, resolver.py
# =============================================================================
cache:
  # Max number of DNS records to hold in memory. 0 to disable.
  size: 10000
  
  # Garbage collection interval (seconds)
  gc_interval: 300
  
  # Cache TTL for upstream failures/NXDOMAIN (if upstream doesn't provide one)
  negative_ttl: 60
  
  # Optimistic Prefetching
  # If a record is accessed within X seconds of expiry, refresh it in background.
  # Set to 0 to disable.
  prefetch_margin: 10
  
  # Minimum hits a record needs before it qualifies for prefetch
  prefetch_min_hits: 3

# Cache for Policy Decisions (e.g., "google.com is BLOCKED for group X")
# Significantly speeds up repeated queries for filtered domains/categories.
decision_cache:
  size: 50000
  ttl: 300

deduplication:
  # Merge identical concurrent requests into one upstream query
  # Prevents "thundering herd" if multiple clients request same domain instantly.
  enabled: true

# =============================================================================
# 6. RATE LIMITING
# found in: resolver.py
# =============================================================================
rate_limit:
  enabled: true
  
  # Time window in seconds to track requests
  window_seconds: 60
  
  # Group clients by subnet (0-32 for IPv4, 0-128 for IPv6)
  # 32/128 means individual IPs. 24/64 means subnets.
  ipv4_mask: 32
  ipv6_mask: 128
  
  # Max UDP queries per window before forcing fallback to TCP (TC Flag set)
  # This mitigates DNS amplification attacks.
  udp_threshold: 100
  
  # Total queries (UDP+TCP) per window before completely dropping packets
  total_threshold: 200

# =============================================================================
# 7. RESPONSE MODIFICATION
# found in: resolver.py
# =============================================================================
response:
  # Randomize order of A/AAAA records (Simple Load balancing for client)
  round_robin_enabled: false
  
  # Recursively resolve CNAMEs and remove the intermediate chain from the answer.
  # Returns only the final IP record to the client (CNAME Flattening).
  cname_collapse: true
  
  # RCODE to return if CNAME collapse results in empty answer: NXDOMAIN or NOERROR
  cname_empty_rcode: "NXDOMAIN"
  
  # Strip Authority and Additional sections to reduce packet size
  minimize_response: false
  
  # --- TTL Normalization ---
  min_ttl: 0
  max_ttl: 86400
  # Sync TTLs across all records in an answer. Options:
  # none, first, last, lowest, highest, average
  ttl_sync_mode: "none"
  
  # --- Blocking Behavior ---
  # DNS RCODE for blocked queries: REFUSED, NXDOMAIN, NOERROR, SERVFAIL
  block_rcode: "REFUSED"
  
  # TTL for blocked responses
  block_ttl: 60
  
  # If specified, return this IP instead of RCODE for A/AAAA blocks (Sinkholing).
  # Use "NULL" for 0.0.0.0 (IPv4) / :: (IPv6)
  block_ip: "NULL"
  
  # How to handle responses containing blocked IPs (e.g. from GeoIP or Lists):
  # - filter: Remove only the blocked IPs from the answer. Return remaining IPs.
  #           If NO IPs remain, the standard 'block_rcode'/'block_ip' is applied.
  # - block:  Block the *entire* response if it contains ANY blocked IP.
  ip_block_mode: "filter"
  
  # Apply blocklists/GeoIP rules to IPs found inside the answer section recursively.
  # If false, only checks explicit IP blocklists, not domain blocklists on answers.
  match_answers_globally: false

# =============================================================================
# 8. FILTERING & CATEGORIZATION
# found in: filtering.py, heuristics.py
# =============================================================================
categorization_enabled: true
categories_file: "categories.json"

filtering:
  # PTR Check Mode
  # - strict: Validate that PTR query names are valid IP-address reversals. Block if invalid.
  # - none:   No validation (Default).
  ptr_check: "none"

  # RCODE to return when ptr_check=strict blocks an invalid PTR query
  ptr_check_rcode: "FORMERR"

# --- Heuristics Engine ---
heuristics:
  enabled: true
  block_threshold: 4
  typosquat_file: "typosquat_targets.txt"
  entropy_threshold_high: 3.8
  entropy_threshold_suspicious: 3.2
  
  # --- TOP-N Popular Domains (NEW) ---
  # File containing popular/trusted 2LD domains (one per line)
  # Sources: Tranco (https://tranco-list.eu/), Majestic Million, Umbrella
  # Format: clean 2LD domains like 'google.com', 'facebook.com'
  topn_file: "top-1m-domains.txt"
  
  # Score reduction when domain matches TOP-N list
  # This helps prevent false positives for legitimate high-traffic domains
  # that might trigger heuristics (e.g. CDN subdomains with random-looking names)
  topn_reduction: 2

# =============================================================================
# 9. CLIENT GROUPS
# found in: server.py, resolver.py
# =============================================================================
# How often to refresh ARP/Neigh tables for MAC resolution (Seconds)
mac_cache_refresh_interval: 300

# Group definitions
# Identifiers can be:
# - IP Address (192.168.1.5)
# - CIDR Subnet (192.168.1.0/24)
# - MAC Address (aa:bb:cc:dd:ee:ff)
# - GeoIP Tag (geoip:US, geoip:EUROPE)
# - Server Bind IP (server_ip:10.0.0.1)
# - Server Port (server_port:5353)
# - Query Domain (domain:home, domain:local)
groups:
  admin_devices:
    - "10.0.0.5"
    - "AA:BB:CC:DD:EE:FF"
  
  local_domains:
    - "domain:home"
    - "domain:local"
    - "domain:lan"

  iot_vlan:
    - { default_action: "BLOCK" }  # Whitelist mode
    - "192.168.10.0/24"

  kids_devices:
    - "192.168.1.50"
    - "192.168.1.51"

  secure_devices:
    - "192.168.1.100"
    - "192.168.1.101"

# =============================================================================
# 10. SCHEDULES
# found in: resolver.py
# =============================================================================
schedules:
  bedtime:
    - { days: ["Sun", "Mon", "Tue", "Wed", "Thu"], start: "20:00", end: "07:00" }
    - { days: ["Fri", "Sat"], start: "22:00", end: "08:00" }
  
  work_hours:
    - { days: ["Mon", "Tue", "Wed", "Thu", "Fri"], start: "09:00", end: "17:00" }

# =============================================================================
# 11. FILTER LISTS
# found in: list_manager.py, filtering.py
# =============================================================================
list_refresh_interval: 86400

lists:
  ad_servers:
    - source: "https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts"
  
  malware_domains:
    - source: "https://urlhaus.abuse.ch/downloads/hostfile/"
  
  my_whitelist:
    - source: "./lists/whitelist.txt"
  
  geo_block:
    - source: "./lists/geo.txt"

# =============================================================================
# 12. POLICIES
# found in: list_manager.py, resolver.py
# =============================================================================
# Policies define what rules apply to DNS queries.
# NEW: resolution_mode and dnssec_mode can be set per-policy
policies:
  DefaultPolicy:
    # Resolution mode: "forward" (default) or "recursive"
    # When "recursive", queries are resolved iteratively from root servers
    # instead of being forwarded to upstream servers.
    resolution_mode: "forward"
    
    upstream_group: "Default"
    block: ["ad_servers", "malware_domains"]
  
  KidsPolicy:
    resolution_mode: "forward"
    upstream_group: "Secure"
    block: ["ad_servers", "malware_domains"]
    category_rules:
      adult: { action: "BLOCK", min_confidence: 60 }
      gambling: { action: "BLOCK" }
      social_media: { action: "BLOCK" }
  
  IoTPolicy:
    resolution_mode: "forward"
    upstream_group: "Default"
    allow: ["my_whitelist"]  # Only allow whitelisted domains
  
  LocalPolicy:
    resolution_mode: "forward"
    upstream_group: "LocalUpstream"
  
  # =========================================================================
  # Example: High-Security Policy with Recursive + DNSSEC
  # =========================================================================
  SecurePolicy:
    # Use recursive resolution instead of forwarding
    resolution_mode: "recursive"
    
    # Override DNSSEC mode for this policy (optional)
    # If not set, uses the global upstream.recursive.dnssec.mode setting
    dnssec_mode: "standard"
    
    block: ["ad_servers", "malware_domains", "geo_block"]
    category_rules:
      malware: { action: "BLOCK" }
      phishing: { action: "BLOCK" }
  
  # =========================================================================
  # Example: Maximum Security (DNSSEC strict mode)
  # =========================================================================
  ParanoidPolicy:
    resolution_mode: "recursive"
    dnssec_mode: "strict"  # Only DNSSEC-validated responses allowed
    block: ["ad_servers", "malware_domains"]

# =============================================================================
# 13. POLICY ASSIGNMENTS
# found in: resolver.py
# =============================================================================
assignments:
  admin_devices:
    policy: "DefaultPolicy"
  
  local_domains:
    policy: "LocalPolicy"
  
  iot_vlan:
    policy: "IoTPolicy"
  
  kids_devices:
    policy: "KidsPolicy"
    schedule: "bedtime"
    schedule_policy: "BLOCK"  # Complete block during schedule
  
  secure_devices:
    policy: "SecurePolicy"
  
  # Default assignment for unmatched clients
  default:
    policy: "DefaultPolicy"

# =============================================================================
# CONFIGURATION EXAMPLES
# =============================================================================

# -----------------------------------------------------------------------------
# EXAMPLE 1: Simple Forwarding (No Recursion)
# -----------------------------------------------------------------------------
# This is the default mode - all queries are forwarded to upstream servers.
#
# upstream:
#   mode: "fastest"
#   groups:
#     Default:
#       servers:
#         - "udp://8.8.8.8:53"
#         - "udp://1.1.1.1:53"
#   recursive:
#     enabled: false

# -----------------------------------------------------------------------------
# EXAMPLE 2: Full Recursive with DNSSEC Logging
# -----------------------------------------------------------------------------
# Use this to test DNSSEC impact before enforcing.
#
# upstream:
#   recursive:
#     enabled: true
#     root_hints:
#       source: "builtin"
#     trust_anchors:
#       source: "builtin"
#     dnssec:
#       mode: "log"  # Log validation results but never block

# -----------------------------------------------------------------------------
# EXAMPLE 3: Full Recursive with DNSSEC Enforcement
# -----------------------------------------------------------------------------
# Production configuration with DNSSEC validation.
#
# upstream:
#   recursive:
#     enabled: true
#     root_hints:
#       source: "url"
#       url: "https://www.internic.net/domain/named.root"
#       refresh_interval: 86400
#     trust_anchors:
#       source: "url"
#       url: "https://data.iana.org/root-anchors/root-anchors.xml"
#       refresh_interval: 86400
#     dnssec:
#       mode: "standard"
#       validation_failure_rcode: "SERVFAIL"
#       disabled_algorithms: [5, 7]  # Disable weak RSASHA1

# -----------------------------------------------------------------------------
# EXAMPLE 4: Hybrid Mode (Recursive for some, Forwarding for others)
# -----------------------------------------------------------------------------
# Use per-policy resolution_mode to mix forwarding and recursive.
#
# policies:
#   HighSecurity:
#     resolution_mode: "recursive"
#     dnssec_mode: "strict"
#   
#   Normal:
#     resolution_mode: "forward"
#     upstream_group: "Default"
#   
#   LocalDomains:
#     resolution_mode: "forward"
#     upstream_group: "LocalUpstream"
#
# assignments:
#   secure_devices:
#     policy: "HighSecurity"
#   local_domains:
#     policy: "LocalDomains"
#   default:
#     policy: "Normal"

# -----------------------------------------------------------------------------
# EXAMPLE 5: Strict DNSSEC for Maximum Security
# -----------------------------------------------------------------------------
# WARNING: This will break access to sites without DNSSEC!
# Many legitimate sites don't have DNSSEC deployed.
#
# upstream:
#   recursive:
#     enabled: true
#     dnssec:
#       mode: "strict"
#       unsigned_zone_rcode: "SERVFAIL"
#       validation_failure_rcode: "SERVFAIL"

