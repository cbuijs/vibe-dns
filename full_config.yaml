# =============================================================================
# 1. LOGGING
# found in: utils.py, defaults.py
# =============================================================================
logging:
  # Logging level: DEBUG, INFO, WARNING, ERROR, CRITICAL
  level: "INFO"
  
  # Print logs to stdout (terminal)
  enable_console: true
  
  # Include timestamp in console logs (set false if using systemd/docker)
  console_timestamp: true
  
  # Write logs to a file
  enable_file: false
  file_path: "./dns_server.log"
  
  # Send logs to local Syslog or remote Syslog server
  enable_syslog: false
  # Can be a file path (e.g., /dev/log) or "host:port" (e.g., 192.168.1.50:514)
  syslog_address: "/dev/log"
  # Protocol if sending over network: UDP or TCP
  syslog_protocol: "UDP"

# =============================================================================
# 2. SERVER NETWORKING
# found in: server.py, resolver.py
# =============================================================================
server:
  # List of IPs to listen on. Use "0.0.0.0" for all IPv4, "::" for all IPv6.
  bind_ip: 
    - "0.0.0.0"
    - "::"
  
  # OPTIONAL: Bind by interface name (requires 'netifaces' module or 'ip' command). 
  # These are resolved to IPs at startup and added to bind_ip.
  # bind_interfaces: 
  #   - "eth0"
  #   - "wg0"
  
  # Ports to listen on (List of integers). Standard is 53.
  port_udp: [53, 5353, 53053]
  port_tcp: [53, 5353, 53053]

  # Max concurrent UDP requests to process simultaneously.
  # Packets exceeding this limit are dropped to prevent resource exhaustion.
  udp_concurrency: 1000
  
  # --- EDNS Client Subnet (ECS) Handling ---
  # Enable parsing of ECS data from incoming clients
  use_ecs: true
  
  # How to handle ECS when forwarding to upstream:
  # - none:     Strip ECS data (Default/Privacy)
  # - preserve: Forward client's provided ECS data if present
  # - add:      Inject the client's actual IP as ECS data
  # - privacy:  Truncate client IP to mask (defined below) before forwarding
  # - override: Force a specific IP (defined below) to be sent as ECS
  forward_ecs_mode: "none"

  # ECS Masks for 'privacy' mode (Subnet bits to keep)
  ecs_ipv4_mask: 24
  ecs_ipv6_mask: 56

  # ECS Overrides for 'override' mode (Simulate request from this IP)
  # ecs_override_ipv4: "1.2.3.4"
  # ecs_override_ipv6: "2001:db8::1"

  # --- MAC Address Handling ---
  # Enable parsing of custom EDNS MAC option (Code 65001)
  use_edns_mac: true
  
  # How to handle MAC forwarding to upstream:
  # - none:     Do not send MAC to upstream
  # - preserve: Forward existing MAC option if present
  # - add:      Resolve client MAC from ARP table and inject it via EDNS
  forward_mac_mode: "none"

# =============================================================================
# 3. GEOIP CONFIGURATION
# found in: geoip.py, cctld.py
# =============================================================================
geoip:
  # Master switch for GeoIP functionality
  enabled: true
  
  # Path to the binary database compiled via geoip_compiler.py
  unified_database: "./geoip.vibe"
  
  # Logic for mapping Domain TLDs (e.g., .cn) vs IP Locations
  # - geoip_only:  Ignore TLDs. Only use IP-based lookup of the answer.
  # - cctld_first: If domain TLD matches a blocked location, block query immediately.
  # - cctld_geoip: Use TLD as a hint to disambiguate IP location.
  cctld_mode: "geoip_only"

# =============================================================================
# 4. UPSTREAM RESOLUTION
# found in: upstream_manager.py
# =============================================================================
upstream:
  # Check if upstreams are reachable before starting the server
  startup_check_enabled: true
  
  # If all configured servers fail, use bootstrap servers as last resort
  fallback_enabled: false
  
  # Allow non-RFC compliant underscores in domain names (e.g., _service.example.com)
  allow_underscores: false
  
  # Load Balancing Strategy:
  # - fastest:     Use server with lowest latency (pings periodically)
  # - loadbalance: Distribute based on average response time
  # - distributed: Weighted distribution based on latency and staleness (ensures all servers are probed)
  # - failover:    Use first server; only switch if it fails
  # - random:      Pick random server per request
  # - roundrobin:  Rotate through servers sequentially
  # - sticky:      Client IP is pinned to specific upstream server
  # - none:        Use first available (dumb forwarder)
  mode: "fastest"
  
  # Seconds between latency probes
  monitor_interval: 60
  
  # Trigger background latency check immediately if a user queries a domain
  monitor_on_query: true
  
  # Domain used for latency probing
  test_domain: "www.google.com"
  
  # Max concurrent connections per HTTP/2 client (for DoH upstreams)
  connection_limit: 20
  
  # --- Circuit Breaker ---
  # Temporarily stops sending queries to a dead upstream
  circuit_breaker_enabled: true
  circuit_failure_threshold: 3   # Number of failures before opening circuit
  circuit_recovery_timeout: 30   # Seconds to wait before retrying a dead server

  # Bootstrap DNS servers 
  # Used to resolve hostnames of DoH/DoT upstreams (e.g. resolving dns.google)
  bootstrap:
    - "8.8.8.8"
    - "1.1.1.1"

  # Control which IP version is resolved for upstream hosts via bootstrap servers.
  # - ipv4: Only request A records (IPv4).
  # - ipv6: Only request AAAA records (IPv6).
  # - both: Request both A and AAAA records (Default).
  # - auto: Detect based on configured bootstrap IPs. 
  #         If all bootstrap servers are only IPv4, only request IPv4.
  #         If all bootstrap servers are only IPv6, only request IPv6.
  #         If all bootstrap servers are both IPv4 and IPv6, request iIPv4 and IPv6.
  bootstrap_resolution_mode: "auto"

  # Upstream Server Definitions
  # Syntax: protocol://host:port/path#forced_ip
  # Protocols: udp, tcp, tls (DoT), https (DoH)
  groups:
    Default:
      servers:
        - url: "udp://8.8.8.8:53"
          priority: 10
        - url: "udp://1.1.1.1:53"
          priority: 20
    
    Secure:
      servers:
        # DoT Example (Forced IP prevents bootstrap lookup)
        - url: "tls://1.1.1.1:853#1.1.1.1"
        # DoH Example
        - url: "https://dns.google:443/dns-query#8.8.4.4"

    LocalUpstream:
      servers:
        - "udp://192.168.1.1:53"  # Local router/DNS

# =============================================================================
# 5. CACHING
# found in: cache_stats.py, resolver.py
# =============================================================================
cache:
  # Max number of DNS records to hold in memory. 0 to disable.
  size: 10000
  
  # Garbage collection interval (seconds)
  gc_interval: 300
  
  # Cache TTL for upstream failures/NXDOMAIN (if upstream doesn't provide one)
  negative_ttl: 60
  
  # Optimistic Prefetching
  # If a record is accessed within X seconds of expiry, refresh it in background.
  # Set to 0 to disable.
  prefetch_margin: 10
  
  # Minimum hits a record needs before it qualifies for prefetch
  prefetch_min_hits: 3

# Cache for Policy Decisions (e.g., "google.com is BLOCKED for group X")
# Significantly speeds up repeated queries for filtered domains/categories.
decision_cache:
  size: 50000
  ttl: 300

deduplication:
  # Merge identical concurrent requests into one upstream query
  # Prevents "thundering herd" if multiple clients request same domain instantly.
  enabled: true

# =============================================================================
# 6. RATE LIMITING
# found in: resolver.py
# =============================================================================
rate_limit:
  enabled: true
  
  # Time window in seconds to track requests
  window_seconds: 60
  
  # Group clients by subnet (0-32 for IPv4, 0-128 for IPv6)
  # 32/128 means individual IPs. 24/64 means subnets.
  ipv4_mask: 32
  ipv6_mask: 128
  
  # Max UDP queries per window before forcing fallback to TCP (TC Flag set)
  # This mitigates DNS amplification attacks.
  udp_threshold: 100
  
  # Total queries (UDP+TCP) per window before completely dropping packets
  total_threshold: 200

# =============================================================================
# 7. RESPONSE MODIFICATION
# found in: resolver.py
# =============================================================================
response:
  # Randomize order of A/AAAA records (Simple Load balancing for client)
  round_robin_enabled: false
  
  # Recursively resolve CNAMEs and remove the intermediate chain from the answer.
  # Returns only the final IP record to the client (CNAME Flattening).
  cname_collapse: true
  
  # RCODE to return if CNAME collapse results in empty answer: NXDOMAIN or NOERROR
  cname_empty_rcode: "NXDOMAIN"
  
  # Strip Authority and Additional sections to reduce packet size
  minimize_response: false
  
  # --- TTL Normalization ---
  min_ttl: 0
  max_ttl: 86400
  # Sync TTLs across all records in an answer. Options:
  # none, first, last, lowest, highest, average
  ttl_sync_mode: "none"
  
  # --- Blocking Behavior ---
  # DNS RCODE for blocked queries: REFUSED, NXDOMAIN, NOERROR, SERVFAIL
  block_rcode: "REFUSED"
  
  # TTL for blocked responses
  block_ttl: 60
  
  # If specified, return this IP instead of RCODE for A/AAAA blocks (Sinkholing).
  # Use "NULL" for 0.0.0.0 (IPv4) / :: (IPv6)
  block_ip: "NULL"
  
  # How to handle responses containing blocked IPs (e.g. from GeoIP or Lists):
  # - filter: Remove only the blocked IPs from the answer. Return remaining IPs.
  #           If NO IPs remain, the standard 'block_rcode'/'block_ip' is applied.
  # - block:  Block the *entire* response if it contains ANY blocked IP.
  ip_block_mode: "filter"
  
  # Apply blocklists/GeoIP rules to IPs found inside the answer section recursively.
  # If false, only checks explicit IP blocklists, not domain blocklists on answers.
  match_answers_globally: false

# =============================================================================
# 8. FILTERING & CATEGORIZATION
# found in: filtering.py, heuristics.py
# =============================================================================
categorization_enabled: true
categories_file: "categories.json"

filtering:
  # PTR Check Mode
  # - strict: Validate that PTR query names are valid IP-address reversals (in-addr.arpa/ip6.arpa). Block if invalid.
  # - none:   No validation (Default).
  ptr_check: "none"

  # RCODE to return when ptr_check=strict blocks an invalid PTR query
  # Options: FORMERR (default), SERVFAIL, REFUSED, NXDOMAIN, NOERROR
  ptr_check_rcode: "FORMERR"

# --- Heuristics Engine (New) ---
heuristics:
  # Enable advanced heuristic analysis for suspicious domains
  enabled: true
  
  # Score threshold to block a domain (1-5)
  # 1 = Slightly suspicious, 5 = Extremely suspicious
  # Recommended: 4
  block_threshold: 4
  
  # File containing high-value targets for typosquatting checks
  # Looks for domains that are 1 character edit away from these targets.
  # If file not found, uses built-in defaults.
  typosquat_file: "typosquat_targets.txt"

  # Entropy Thresholds (Shannon Entropy 0.0 - 6.0+)
  # Controls how "random" a domain needs to be to trigger alerts.
  # Higher = Less sensitive (fewer false positives)
  # Lower  = More sensitive (more blocks)
  entropy_threshold_high: 3.8       # Adds 3 points (Likely DGA)
  entropy_threshold_suspicious: 3.2 # Adds 1 point  (Unusual)

# =============================================================================
# 9. CLIENT GROUPS
# found in: server.py, resolver.py
# =============================================================================
# How often to refresh ARP/Neigh tables for MAC resolution (Seconds)
mac_cache_refresh_interval: 300

# Group definitions
# Identifiers can be:
# - IP Address (192.168.1.5)
# - CIDR Subnet (192.168.1.0/24)
# - MAC Address (aa:bb:cc:dd:ee:ff)
# - GeoIP Tag (geoip:US, geoip:EUROPE) - Matches based on Source IP location
# - Server Bind IP (server_ip:10.0.0.1) - useful for VLAN gateways listening on specific IPs
# - Server Port (server_port:5353) - useful for specific listeners
# - Query Domain (domain:home, domain:local) - Matches query TLD or domain suffix
groups:
  admin_devices:
    - "10.0.0.5"
    - "AA:BB:CC:DD:EE:FF"
  
  # Local network domains - forward to local DNS
  local_domains:
    - "domain:home"
    - "domain:local"
    - "domain:lan"
    - "domain:internal.corp.com"

  iot_vlan:
    # OPTIONAL: Set a default action for this group (ALLOW, BLOCK, DROP)
    # If set, this overrides policies for unhandled domains, effectively acting as a whitelist mode if set to BLOCK.
    - { default_action: "ALLOW" }
    - "10.0.50.0/24"
    - "server_ip:10.0.50.1"
  
  kids:
    - "10.0.0.10"
    - "geoip:NL" # Example: Apply 'kids' policy to anyone connecting from Netherlands IP
    
  vpn_users:
    - "server_ip:10.8.0.1"

# Load groups from external text files (one identifier per line)
# These files are auto-reloaded based on refresh_interval.
group_files:
  refresh_interval: 300
  kids: "./groups/kids.txt"

# =============================================================================
# 10. SCHEDULES
# found in: resolver.py
# =============================================================================
schedules:
  bedtime:
    - { days: ["Mon", "Tue", "Wed", "Thu", "Sun"], start: "21:00", end: "07:00" }
    - { days: ["Fri", "Sat"], start: "23:00", end: "08:00" }

  work_hours:
    - { days: ["Mon", "Tue", "Wed", "Thu", "Fri"], start: "09:00", end: "17:00" }

# =============================================================================
# 11. FILTER LISTS
# found in: list_manager.py
# =============================================================================
# Auto-refresh interval for downloading lists (seconds)
list_refresh_interval: 86400

lists:
  # Remote HTTP source
  ad_servers:
    - source: "https://raw.githubusercontent.com/StevenBlack/hosts/master/hosts"
      # Parsing mode:
      # - exact:     Matches domain exactly
      # - inclusive: Matches domain and all subdomains (example.com matches sub.example.com)
      # - exclusive: Matches only subdomains (*.example.com)
      hosts_domain_type: "inclusive"
  
  # Local file source
  my_whitelist:
    - source: "./lists/whitelist.txt"
      hosts_domain_type: "exact"
      
  # GeoIP blocking list (uses tags like @@CN, @@RUSSIA, @AS15169)
  # Syntax: 
  #   @@TAG = Block Query (ccTLD) AND Answer (IP)
  #   @TAG  = Block Query (ccTLD) only
  #   @AS#  = Block Answer (ASN)
  geo_block:
    - source: "./lists/geo.txt"

# =============================================================================
# 12. POLICIES
# found in: filtering.py, resolver.py
# =============================================================================
# RULE PRIORITY: ALLOW > BLOCK > DROP
# If a rule exists in both an allowed list and a blocked list, ALLOW wins.
#
# PROCESSING FLOW:
# 1. Query Analysis: Domain -> GeoIP/ccTLD -> Regex -> Heuristics
#    (If Query is allowed explicitly, Upstream processing occurs without Answer checks)
#
# 2. Upstream Resolution
#
# 3. Answer Analysis: Domain -> ASN -> GeoIP -> IP/CIDR -> Regex
#    (Only if Query was not explicitly allowed by a rule)

policies:
  # Default policy if no group matches (Implicit)
  Default:
    upstream_group: "Default"
  
  # Strict policy for Kids
  KidsPolicy:
    upstream_group: "Secure"
    
    # Lists to apply
    allow: ["my_whitelist"]
    block: ["ad_servers", "geo_block"]
    # Silent drop (no response) - good for telemetry/tracking
    drop: []
    
    # Query Type Filtering
    allowed_types: ["A", "AAAA", "CNAME", "HTTPS"] # If set, only these are allowed
    blocked_types: ["TXT", "ANY"] # Returns Block RCODE
    dropped_types: []             # Returns nothing (timeout)
    
    # Category-based rules (requires categorization_enabled)
    # actions: ALLOW, BLOCK, DROP
    category_rules:
      gambling:
        min_confidence: 85  # Only block if confidence > 85%
        action: "BLOCK"
      adult:
        min_confidence: 60
        action: "BLOCK"
      social_media:
        min_confidence: 90
        action: "DROP"

  # Example of an "Allow-List Only" policy (Walled Garden)
  IoTPolicy:
    upstream_group: "Default"
    allow: ["my_whitelist"]
    # Note: To make this strictly whitelist-only, set the Group's 'default_action' to BLOCK
    # or ensure a 'block all' list is applied here.

  # Local DNS
  LocalDNS:
    upstream_group: "LocalUpstream"


# =============================================================================
# 13. ASSIGNMENTS
# found in: resolver.py
# =============================================================================
assignments:
  # Group Name matches keys in 'groups' section
  kids:
    policy: "KidsPolicy"
    schedule: "bedtime"
    # Policy to apply when schedule is ACTIVE (Built-in policies: BLOCK, ALLOW, DROP)
    # Can also be a custom policy name
    schedule_policy: "BLOCK" 
    
  iot_vlan:
    policy: "IoTPolicy"
    
  admin_devices:
    policy: "Default"

  local_network:
    policy: "LocalDNS"

